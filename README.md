# Arabic-numbers-to-Roman-Numeral
本程式是在上過學校課程之後，想測試自己是否有將課程所學記進腦袋而嘗試的測驗

在課堂中，老師以羅馬數字轉整數為例，進行了C++語法中字串string的示範

而我決定以此為延伸，嘗試看看反向操作，將整數轉為羅馬數字

以下是我在過程中思考的方式與發現的問題。

## 一、層層拆解
在羅馬數字的規則中，以下的每個符號代表了一個數值
```
I=1 V=5 X=10 L=50 C=100 D=500 M=1000
```

我最初的設想，便是在輸入一個整數後，**用if來將數字層層拆解**

例如當數字大於1000時，便在字串s加上一個M，而後將數字減去1000
```cpp
while(AN > 0)
{
  if(AN >= 1000)
  {
    s = s + 'M';
    AN = AN-1000;
  }
  ...
  ...
}
```
以此類推，當數字大於500時，就在字串中加上D和減去500，直到數字被扣到0為止

但此時就出現了第一個問題，眾所皆知，羅馬數字中的4會表示為IV，但是在現在的程式碼中，結果卻不一樣
```
輸入 4
輸出 IIII
```


## 二、羅馬數字中的特例
會出現上面的問題，首先要提到羅馬數字中的另一個規則:
>在較大的羅馬數字的右邊記上較小的羅馬數字，表示大數字加小數字。

>在較大的羅馬數字的左邊記上較小的羅馬數字，表示大數字減小數字。

但是在現在的程式中，沒辦法將4轉換成IV(5-1)的形式

這樣的問題將不只出現在4，同時也會出現在9、40、90等數字中

於是我選擇的作法是：**將這些"特例"逐個加入if的判斷中**

首先我先找出了1000以下，可能出現的所有特例
```
4=IV 9=IX 40=XL 90=XC 400=CD 900=CM
```
再將這些特例，同樣也逐步輸入在if的判斷中
```cpp
while(AN > 0)
{
  ...
  ...
  if(AN >= 900)
  {
    s = s + "CM"; //因為有兩個字符，所以此處使用雙引號
    AN = AN-900;
  }
  ...
  ...
  
}
```
這樣一來，特例數字的問題便迎刃而解

緊接著，我又遇到了第二個問題
```
輸入 4000
輸出 MCMDCDCXCLXLXIXVIVIDCXCLXLXIX
```
```
輸入 800
輸出 DCXCLXLX
```
依照規則來說，輸入4000，正確的輸出應為MMMM；輸入800，正確的輸出應為DCCC，現在的結果卻截然不同

## 三、個別處理千、百、十位數
在上面的程式中，我忽略了若是有多個1000的情況，**應該要先將千位數計算完畢**、再計算百位數、十位數...

導致在計算上面的4000時，再減去1000之後，便直接進入了900的if判斷，進而導致混亂的答案出現

這樣的問題，同樣也會出現在100和10

於是我將1000、100、10個別拉出來，將程式碼修改為while迴圈
```cpp
while(AN >= 1000)
{
  s = s + 'M';
  AN = AN-1000;	
}
...
...
```
這樣，程式便能依照位數大小，好好地逐層拆解數字並轉換為羅馬數字

## 四、額外規則
在古羅馬時期，人們尚未有0和負數的概念，所以羅馬數字也沒有表現0和負數的方式

除此之外，羅馬數字中若連續出現了四次以上同樣的字母，便會在字母上加一條橫線，表示將這個數乘以1000

若要再加上這條規則，程式又會變得更複雜，也有許多的特例需要應對，我的能力尚不及此

所以我在程式上額外添加了兩條限制
```cpp
if(AN < 1)
{
  cout << "數值不可小於1" << endl;
  return 0;
}
	
if(AN > 9999)
{
  cout << "數值過大" << endl;
  return 0;
}
```
讓使用者不能輸入小於1和大於9999的數值

至此，整個程式便能夠正常且正確的運作了，可喜可賀
